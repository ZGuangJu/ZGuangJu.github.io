(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{591:function(v,_,t){"use strict";t.r(_);var e=t(2),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"第3章-流、元素和基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第3章-流、元素和基本概念"}},[v._v("#")]),v._v(" 第3章 流、元素和基本概念")]),v._v(" "),t("h2",{attrs:{id:"块级元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#块级元素"}},[v._v("#")]),v._v(" 块级元素")]),v._v(" "),t("p",[t("code",[v._v("li")]),v._v("元素默认的"),t("code",[v._v("display")]),v._v("值是"),t("code",[v._v("list-item")]),v._v("，和"),t("code",[v._v("table")]),v._v("都是块级元素，在一个水平流上只能单独显示一个元素，多个则换行显示。可以配合"),t("code",[v._v("clear")]),v._v("属性来清除浮动带来的影响。")]),v._v(" "),t("div",{staticClass:"language-css extra-class"},[t("pre",{pre:!0,attrs:{class:"language-css"}},[t("code",[v._v("    "),t("span",{pre:!0,attrs:{class:"token selector"}},[v._v(".clear:after")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n        "),t("span",{pre:!0,attrs:{class:"token property"}},[v._v("content")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("''")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n        "),t("span",{pre:!0,attrs:{class:"token property"}},[v._v("display")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" table"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("/*也可以是block，或是list-item*/")]),v._v("\n        "),t("span",{pre:!0,attrs:{class:"token property"}},[v._v("clear")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" both"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),t("p",[v._v("实际开发中，不推荐使用"),t("code",[v._v("list-item")]),v._v("，一是会出现项目符号，而是IE不支持伪元素"),t("code",[v._v(":after")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"为什么list-item元素会出现项目符号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么list-item元素会出现项目符号"}},[v._v("#")]),v._v(" 为什么"),t("code",[v._v("list-item")]),v._v("元素会出现项目符号")]),v._v(" "),t("p",[v._v("list-item元素出现项目符号是因为生成了一个附加盒子（"),t("strong",[v._v("标记盒子")]),v._v("），专门用来放圆点、数字这些项目符号。IE下伪元素不支持"),t("code",[v._v("list-item")]),v._v("或许就是无法创建"),t("strong",[v._v("标记盒子")]),v._v("导致的。")]),v._v(" "),t("h3",{attrs:{id:"display-inline-table-的盒子是怎样组成的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#display-inline-table-的盒子是怎样组成的"}},[v._v("#")]),v._v(" "),t("code",[v._v("display: inline-table;")]),v._v("的盒子是怎样组成的")]),v._v(" "),t("p",[v._v("外面内联，里面"),t("code",[v._v("table")]),v._v("，元素和文字在一行显示。")]),v._v(" "),t("h3",{attrs:{id:"width-height作用在哪个盒子上"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#width-height作用在哪个盒子上"}},[v._v("#")]),v._v(" "),t("code",[v._v("width/height")]),v._v("作用在哪个盒子上")]),v._v(" "),t("p",[t("code",[v._v("width/height")]),v._v("作用在"),t("strong",[v._v("里面的盒子")]),v._v("，也就是"),t("strong",[v._v("容器盒子")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"width-height作用的具体细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#width-height作用的具体细节"}},[v._v("#")]),v._v(" "),t("code",[v._v("width/height")]),v._v("作用的具体细节")]),v._v(" "),t("p",[v._v("块级元素的流体特性主要体现在水平方向上。")]),v._v(" "),t("h3",{attrs:{id:"深藏不漏的width-auto"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深藏不漏的width-auto"}},[v._v("#")]),v._v(" 深藏不漏的"),t("code",[v._v("width:auto")])]),v._v(" "),t("p",[t("code",[v._v("width")]),v._v("的默认值是"),t("code",[v._v("auto")]),v._v("，它至少包含4中不同的宽度表现：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("充分利用可用空间")]),v._v("。元素默认宽度是100%父级容器。")]),v._v(" "),t("li",[t("strong",[v._v("收缩与包裹")]),v._v("。典型代表是浮动、绝对定位和"),t("code",[v._v("inline-block")]),v._v("元素或"),t("code",[v._v("table")]),v._v("元素。")]),v._v(" "),t("li",[t("strong",[v._v("收缩到最小")]),v._v("。这个最容易出现在"),t("code",[v._v("table-layout")]),v._v("为"),t("code",[v._v("auto")]),v._v("表格中。")]),v._v(" "),t("li",[t("strong",[v._v("超出容器限制")]),v._v("。除非有明确的"),t("code",[v._v("width")]),v._v("设置，否则表格"),t("code",[v._v("min-content")]),v._v("的尺寸都不会主动超出父容器的宽度。特殊情况：内容很长的英文和数字，或者内联元素设置为"),t("code",[v._v("white-space:nowrap;")]),v._v("。这种情况称为"),t("code",[v._v("max-content")]),v._v("。")])]),v._v(" "),t("p",[t("strong",[v._v("1. 外部尺寸与流体特性")])]),v._v(" "),t("ol",[t("li",[v._v("正常流宽度。**无宽度，无图片，无浮动。**充分利用浏览器自身的行为特性来完成页面布局。表现为“外部尺寸”的块级元素一旦设置了宽度就会丢失流动性。")]),v._v(" "),t("li",[v._v("格式化宽度。仅出现在“绝对定位模型”中，在默认情况下，绝对定位元素的宽度表现为“包裹性”，宽度由内部尺寸决定。对于"),t("strong",[v._v("非替代元素")]),v._v("，当"),t("code",[v._v("left/top")]),v._v("或"),t("code",[v._v("top/bottom")]),v._v("对立方位的属性值同时存在的时候，元素的宽度表现为"),t("strong",[v._v("格式化宽度")]),v._v("，其宽度大小相对于最近的具有定位特性的祖先元素计算。格式化宽度具有完全的流体性，也就是"),t("code",[v._v("margin/padding/border/content")]),v._v("区域会自动分配水平（垂直）空间。")])]),v._v(" "),t("p",[t("strong",[v._v("2. 内部尺寸与流体特性")])]),v._v(" "),t("p",[v._v("内部尺寸有3种表现特性：")]),v._v(" "),t("ol",[t("li",[v._v("包裹性。对于一个元素，如果其"),t("code",[v._v("display:inline-block;")]),v._v("，那么里面的内容宽度不会超过容器。\n"),t("ul",[t("li",[v._v("按钮是CSS中最具有代表性的"),t("code",[v._v("inline-block")]),v._v("元素，也是包裹性最好的实例。具体表现为："),t("strong",[v._v("按钮文字越多则宽度越宽（内部尺寸特性），如果文字太多则会在容器的宽度处自动换行（自适应特性）。")])]),v._v(" "),t("li",[t("code",[v._v("input")]),v._v("标签按钮，默认"),t("code",[v._v("white-space:pre;")]),v._v("不会换行；需要将"),t("code",[v._v("pre")]),v._v("值重置为默认的"),t("code",[v._v("normal")]),v._v("。")])])])]),v._v(" "),t("p",[t("strong",[v._v("包裹性在实际开发中的作用")])]),v._v(" "),t("blockquote",[t("p",[v._v("需求：页面某个模块的文字内容是动态的，可长可短。文字少的时候居中显示，文字超过一行的时候居左显示。该如何实现？")])]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v(".box {\n    text-align: center;\n}\n\n.content {\n    display: inline-block;\n    text-align: left;\n}\n")])])]),t("p",[v._v("除了"),t("code",[v._v("inline-block")]),v._v("元素，绝对定位和浮动元素都具有包裹性，均有类似的智能宽度行为。")]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[v._v("首选最小宽度。元素最适合的最小宽度。具体表现规则：")]),v._v(" "),t("ul",[t("li",[v._v("东亚文字最小宽度为每个汉字的宽度。")]),v._v(" "),t("li",[v._v("西方文字最小宽度由特定的连续的英文字符单元决定。英文字符一般会终止于空格、短横线、问好以及其他非英文字符。")]),v._v(" "),t("li",[v._v("要让英文字符的每个字符都用最小宽度单元，可以使用"),t("code",[v._v("word-break:break-all;")])]),v._v(" "),t("li",[v._v("图片的替代元素的最小宽度是该元素内容本身的宽度。")])])]),v._v(" "),t("li",[t("p",[v._v("最大宽度。最大连续内联盒子的宽度。")])])]),v._v(" "),t("h3",{attrs:{id:"width值作用的细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#width值作用的细节"}},[v._v("#")]),v._v(" "),t("code",[v._v("width")]),v._v("值作用的细节")]),v._v(" "),t("ol",[t("li",[v._v("流动性丢失\n"),t("ul",[t("li",[v._v("块级元素设定"),t("code",[v._v("width")]),v._v("具体数值，则元素的流动性就会被阻断。")])])]),v._v(" "),t("li",[v._v("与实际表现不一致\n"),t("ul",[t("li",[t("code",[v._v("padding")]),v._v("、"),t("code",[v._v("border")]),v._v("属性发生改变会影响"),t("code",[v._v("content")]),v._v("内容的尺寸，出现页面布局错位。")])])])]),v._v(" "),t("h3",{attrs:{id:"css流体布局下的宽度分离原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css流体布局下的宽度分离原则"}},[v._v("#")]),v._v(" CSS流体布局下的宽度分离原则")]),v._v(" "),t("p",[t("strong",[v._v("宽度分离原则")]),v._v("，就是CSS中的"),t("code",[v._v("width")]),v._v("属性不与影响宽度的"),t("code",[v._v("padding/border")]),v._v("属性共存。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v(".box {\n    width: 100px;\n    border: 1px solid #ccc;\n}\n")])])]),t("p",[t("code",[v._v("width")]),v._v("独占一层标签，而"),t("code",[v._v("padding/border/margin")]),v._v("利用流动性在内部自适应呈现。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v(".father {\n    width: 100px;\n}\n\n.son {\n    margin: 0 20px;\n    border: 1px solid #ccc;\n}\n")])])]),t("h3",{attrs:{id:"改变width-height作用细节的box-sizing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#改变width-height作用细节的box-sizing"}},[v._v("#")]),v._v(" 改变"),t("code",[v._v("width/height")]),v._v("作用细节的"),t("code",[v._v("box-sizing")])]),v._v(" "),t("p",[t("strong",[t("code",[v._v("box-sizing")]),v._v("的作用")])]),v._v(" "),t("p",[v._v("默认情况下，"),t("code",[v._v("width")]),v._v("是作用在"),t("code",[v._v("content box")]),v._v("上，"),t("code",[v._v("box-sizing")]),v._v("的作用就是可以把"),t("code",[v._v("width")]),v._v("作用的盒子变成其他几个。")]),v._v(" "),t("p",[t("code",[v._v("box-sizing: border-box;")]),v._v("就是让100像素的宽度直接作用在"),t("code",[v._v("border box")]),v._v("上，从默认的"),t("code",[v._v("content box")]),v._v("变成"),t("code",[v._v("border box")]),v._v("。此时，"),t("code",[v._v("content box")]),v._v("从宽度值中释放，形成了局部的流动性，和"),t("code",[v._v("padding")]),v._v("一起自动分配"),t("code",[v._v("width")]),v._v("值。")]),v._v(" "),t("p",[v._v("box-sizing不支持"),t("code",[v._v("margin-box")]),v._v("，只有当元素没有水平"),t("code",[v._v("margin")]),v._v("时，"),t("code",[v._v("box-sizing")]),v._v("才能真正计算，"),t("strong",[v._v("宽度分离")]),v._v("等策略可以彻底解决所有的宽度计算问题。")]),v._v(" "),t("blockquote",[t("p",[v._v("在CSS世界中，唯一离不开"),t("code",[v._v("box-sizing:border-box;")]),v._v("的就是原生普通文本框"),t("code",[v._v("input")]),v._v("和"),t("code",[v._v("textarea")]),v._v("的100%自适应父容器宽度。\n替换元素的特性之一是尺寸由内部元素决定，且无论其"),t("code",[v._v("display")]),v._v("属性值是"),t("code",[v._v("inline")]),v._v("还是"),t("code",[v._v("block")]),v._v("。对于非替换元素，如果"),t("code",[v._v("display")]),v._v("值是"),t("code",[v._v("block")]),v._v("，就会具有流动性，宽度由外部尺寸决定，但是替换元素的宽度不受"),t("code",[v._v("display")]),v._v("水平影响，因此，通过修改"),t("code",[v._v("textarea")]),v._v("的"),t("code",[v._v("display")]),v._v("水平是无法让尺寸100%自适应父容器。")])]),v._v(" "),t("h3",{attrs:{id:"相对简单的height-auto"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相对简单的height-auto"}},[v._v("#")]),v._v(" 相对简单的"),t("code",[v._v("height:auto")])]),v._v(" "),t("h3",{attrs:{id:"关于height-100"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于height-100"}},[v._v("#")]),v._v(" 关于"),t("code",[v._v("height:100%")])]),v._v(" "),t("p",[v._v("对于"),t("code",[v._v("width")]),v._v("属性，父元素"),t("code",[v._v("width")]),v._v("设为"),t("code",[v._v("auto")]),v._v("，其百分比也支持；但是对于"),t("code",[v._v("height")]),v._v("属性，如果父元素"),t("code",[v._v("height")]),v._v("设为"),t("code",[v._v("auto")]),v._v("，只要子元素在文档流中，其百分比完全被忽略。")]),v._v(" "),t("blockquote",[t("p",[v._v("对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。")])]),v._v(" "),t("p",[t("strong",[v._v("1. 父级没有具体高度值，"),t("code",[v._v("height:100%;")]),v._v("会无效")])]),v._v(" "),t("blockquote",[t("p",[v._v("浏览器渲染的基本原理：首先，先下载文档内容，加载头部的样式资源，然后按照从上而下、自外而内的顺序渲染DOM内容。")])]),v._v(" "),t("p",[v._v("如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为"),t("code",[v._v("auto")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("2. 让元素支持"),t("code",[v._v("height:100%")]),v._v("效果")])]),v._v(" "),t("ol",[t("li",[t("p",[v._v("设定显式的高度值。")]),v._v(" "),t("p",[v._v("html, body {\nheight: 100%;\n}")])]),v._v(" "),t("li",[t("p",[v._v("使用绝对定位。")]),v._v(" "),t("p",[v._v("div {\nheight: 100%;\nposition: absolute;\n}")])])]),v._v(" "),t("blockquote",[t("p",[v._v("绝对定位的宽高百分比计算是相对于"),t("code",[v._v("padding box")]),v._v("，也就是会把"),t("code",[v._v("padding")]),v._v("大小值计算在内。非绝对定位元素则是相对于"),t("code",[v._v("content box")]),v._v("计算。")])]),v._v(" "),t("p",[t("strong",[v._v("图片左右半区点击分别上一张图下一张图效果")])]),v._v(" "),t("p",[v._v("在图片外面包一层具有“包裹性”同时具有定位特性的标签。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v(".box {\n    display: inline-block;\n    position: relative;\n}\n")])])]),t("p",[v._v("在图片上覆盖两个绝对定位，同时设"),t("code",[v._v("height:100%;")]),v._v("，则无论图片多高，左右半区都能自动和图片高度一模一样，无需任何使用JS的计算。")]),v._v(" "),t("h2",{attrs:{id:"min-width-max-width和min-height-max-height"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#min-width-max-width和min-height-max-height"}},[v._v("#")]),v._v(" "),t("code",[v._v("min-width/max-width")]),v._v("和"),t("code",[v._v("min-height/max-height")])]),v._v(" "),t("h3",{attrs:{id:"为流体而生的min-width-max-width"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为流体而生的min-width-max-width"}},[v._v("#")]),v._v(" 为流体而生的"),t("code",[v._v("min-width/max-width")])]),v._v(" "),t("p",[t("code",[v._v("min-width/max-width")]),v._v("出现的场景一定是自适应布局或流体布局中。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v(".container {\n    min-width: 1200px;\n    max-width: 1400px;\n}\n")])])]),t("p",[v._v("为了避免图片在移动端展示过大影响体验，经常会有下面的"),t("code",[v._v("max-width")]),v._v("限制：")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v("img {\n    max-width: 100%;\n    height: auto !important;\n}\n")])])]),t("p",[t("code",[v._v("height:auto;")]),v._v("是必须的，否则如果原始图片有设定"),t("code",[v._v("height")]),v._v("，"),t("code",[v._v("max-width")]),v._v("生效时图片就会被水平压缩。强制"),t("code",[v._v("height")]),v._v("为"),t("code",[v._v("auto")]),v._v("可以确保宽度不超出的同时使图片保持原来的比例。")]),v._v(" "),t("h3",{attrs:{id:"与众不同的初始值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#与众不同的初始值"}},[v._v("#")]),v._v(" 与众不同的初始值")]),v._v(" "),t("p",[t("code",[v._v("max-width/max-height")]),v._v("的初始值是"),t("code",[v._v("none")]),v._v("，"),t("code",[v._v("min-width/min-height")]),v._v("的初始值是"),t("code",[v._v("auto")]),v._v("。")]),v._v(" "),t("ol",[t("li",[t("code",[v._v("min-height/width")]),v._v("的值为"),t("code",[v._v("auto")]),v._v("合法。")]),v._v(" "),t("li",[v._v("数值变化无动画。"),t("code",[v._v("min-height")]),v._v("的初始值是"),t("code",[v._v("auto")]),v._v("。")])]),v._v(" "),t("h3",{attrs:{id:"超越-important-超越最大"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#超越-important-超越最大"}},[v._v("#")]),v._v(" 超越"),t("code",[v._v("!important")]),v._v("，超越最大")]),v._v(" "),t("p",[t("strong",[v._v("1. 超越"),t("code",[v._v("!important")])])]),v._v(" "),t("p",[v._v("超越"),t("code",[v._v("!important")]),v._v("指的是"),t("code",[v._v("max-width")]),v._v("会覆盖"),t("code",[v._v("width")]),v._v("。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v('<img src="1.jpg" style="width: 480px !important;" alt="">\nimg {\n    max-width: 256px;\n}\n')])])]),t("p",[v._v("最终图片显示宽度"),t("code",[v._v("256px")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("2. 超越最大")])]),v._v(" "),t("p",[t("strong",[v._v("超越最大")]),v._v("指的是"),t("code",[v._v("min-width")]),v._v("覆盖"),t("code",[v._v("max-width")]),v._v("，此规则发生在"),t("code",[v._v("min-width")]),v._v("和"),t("code",[v._v("max-width")]),v._v("冲突的时候。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v(".container {\n    min-width: 1400px;\n    max-width: 1200px;\n}\n")])])]),t("p",[v._v("最小宽度设置比最大宽度还大，这个时候，"),t("code",[v._v("min-width")]),v._v("显示，"),t("code",[v._v("max-width")]),v._v("被忽略。"),t("code",[v._v(".container")]),v._v("元素表现为至少"),t("code",[v._v("1400px")]),v._v("宽度。")]),v._v(" "),t("h3",{attrs:{id:"任意高度元素的展开收起动画技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任意高度元素的展开收起动画技术"}},[v._v("#")]),v._v(" 任意高度元素的展开收起动画技术")]),v._v(" "),t("p",[t("strong",[v._v("元素展开收起时有明显的高度滑动效果")])]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v(".element {\n    max-height: 0;\n    overflow: hidden;\n    transition: max-height .25s;\n}\n\n.element.active {\n    max-height: 666px;\n}\n")])])]),t("p",[t("code",[v._v("max-height")]),v._v("使用足够安全的最小值，避免出现延迟。")]),v._v(" "),t("h2",{attrs:{id:"内联元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内联元素"}},[v._v("#")]),v._v(" 内联元素")]),v._v(" "),t("p",[v._v("在CSS世界中，内联元素是最为重要的。这些CSS属性往往具有继承特性。")]),v._v(" "),t("h3",{attrs:{id:"哪些元素是内联元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哪些元素是内联元素"}},[v._v("#")]),v._v(" 哪些元素是内联元素")]),v._v(" "),t("p",[t("strong",[v._v("1. 从定义看")])]),v._v(" "),t("p",[v._v("内联元素特指“外在盒子”，和"),t("code",[v._v("display:inline;")]),v._v("的元素不是一个概念。")]),v._v(" "),t("p",[t("strong",[v._v("2. 从表现看")])]),v._v(" "),t("p",[v._v("内联元素的典型特性是可以和文字在一行显示。")]),v._v(" "),t("h3",{attrs:{id:"内联盒模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内联盒模型"}},[v._v("#")]),v._v(" 内联盒模型")]),v._v(" "),t("ol",[t("li",[v._v("内容区域。\n"),t("ul",[t("li",[t("strong",[v._v("内容区域")]),v._v("指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个"),t("code",[v._v("字符盒子")]),v._v("。")]),v._v(" "),t("li",[v._v("但是像图片这类替换元素，内容区域可以看成元素本身。可以把文本选中的背景色区域作为内容区域。")]),v._v(" "),t("li")])]),v._v(" "),t("li",[v._v("内联盒子。\n"),t("ul",[t("li",[t("strong",[v._v("内联盒子")]),v._v("不会让内容成块显示，而是排成一行，"),t("strong",[v._v("内联盒子")]),v._v("指的就是“外在盒子”，用来决定元素是内联还是块级。")]),v._v(" "),t("li",[t("strong",[v._v("外在盒子")]),v._v("又可以划分为“内联盒子”和“匿名内联盒子”两类：\n"),t("ul",[t("li",[v._v("外部内联标签"),t("code",[v._v("span")]),v._v("、"),t("code",[v._v("a")]),v._v("、"),t("code",[v._v("em")]),v._v("等，则属于“内联盒子”；如果这是文字"),t("code",[v._v("<p>这是一行普通文字，这里有个<em>em</em>标签。（这里是匿名内联盒子）</p>")]),v._v("，则属于“匿名内联盒子”。")]),v._v(" "),t("li",[v._v("并非单独文字都是“匿名内联盒子”，关键要看前后的标签是内联还是块级。")])])])])]),v._v(" "),t("li",[v._v("行框盒子。\n"),t("ul",[t("li",[v._v("每一行就是一个“行框盒子”，每个“行框盒子”又是由一个个“内联盒子”组成。")])])]),v._v(" "),t("li",[v._v("包含盒子。\n"),t("ul",[t("li",[t("code",[v._v("p")]),v._v("标签就是一个"),t("strong",[v._v("包含盒子")]),v._v("，此盒子由一行一行的“行框盒子”组成。")])])])]),v._v(" "),t("h3",{attrs:{id:"幽灵空白节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#幽灵空白节点"}},[v._v("#")]),v._v(" 幽灵空白节点")]),v._v(" "),t("p",[t("strong",[v._v("幽灵空白节点")]),v._v("具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，但又确实存在，表现如同文本节点一样。")]),v._v(" "),t("p",[t("strong",[v._v("幽灵空白节点")]),v._v("是一个存在于每个“行框盒子”前面，同时具有该元素的字体和行高属性的"),t("code",[v._v("0")]),v._v("宽度的内联盒。")])])}),[],!1,null,null,null);_.default=a.exports}}]);